<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, viewport-fit=cover"
		/>
		<title>Dual Camera Capture</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
					Oxygen, Ubuntu, Cantarell, sans-serif;
				background-color: #000;
				overflow: hidden;
				height: 100vh;
				height: 100dvh;
			}

			#container {
				position: relative;
				width: 100vw;
				height: 100vh;
				height: 100dvh;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			#mainVideo {
				width: 100%;
				height: 100%;
				object-fit: cover;
			}

			#mainVideo.front-camera {
				transform: scaleX(-1);
			}

			#overlayVideo {
				position: absolute;
				top: 20px;
				left: 20px;
				width: 150px;
				height: 200px;
				object-fit: cover;
				border: 3px solid #000;
				border-radius: 12px;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
				cursor: pointer;
			}

			#overlayVideo.front-camera {
				transform: scaleX(-1);
			}

			#overlayError {
				position: absolute;
				top: 20px;
				left: 20px;
				width: 150px;
				height: 200px;
				background-color: rgba(40, 40, 40, 0.95);
				border: 3px solid #ff6b6b;
				border-radius: 12px;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
				display: none;
				align-items: center;
				justify-content: center;
				padding: 15px;
				text-align: center;
			}

			#overlayError.show {
				display: flex;
			}

			#overlayError .error-content {
				color: #fff;
			}

			#overlayError .error-icon {
				font-size: 32px;
				margin-bottom: 8px;
			}

			#overlayError .error-message {
				font-size: 12px;
				line-height: 1.4;
			}

			#controls {
				position: absolute;
				bottom: max(30px, env(safe-area-inset-bottom));
				left: 50%;
				transform: translateX(-50%);
				display: flex;
				gap: 15px;
				z-index: 10;
				padding: 0 20px;
			}

			button {
				padding: 15px 30px;
				font-size: 16px;
				font-weight: 600;
				border: none;
				border-radius: 25px;
				cursor: pointer;
				transition: all 0.3s ease;
				box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
			}

			#captureBtn {
				background-color: #fff;
				color: #000;
			}

			#captureBtn:hover {
				transform: scale(1.05);
				box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
			}

			#captureBtn:active {
				transform: scale(0.95);
			}

			#switchBtn {
				background-color: rgba(255, 255, 255, 0.3);
				color: #fff;
				backdrop-filter: blur(10px);
			}

			#switchBtn:hover {
				background-color: rgba(255, 255, 255, 0.4);
			}

			#status {
				position: absolute;
				top: 20px;
				right: 20px;
				background-color: rgba(0, 0, 0, 0.7);
				color: #fff;
				padding: 10px 15px;
				border-radius: 8px;
				font-size: 14px;
				display: none;
			}

			#status.show {
				display: block;
			}

			canvas {
				display: none;
			}

			@media (max-width: 768px) {
				#overlayVideo,
				#overlayError {
					width: 120px;
					height: 160px;
				}

				#controls {
					bottom: max(40px, calc(env(safe-area-inset-bottom) + 20px));
					gap: 10px;
				}

				button {
					padding: 12px 20px;
					font-size: 14px;
				}
			}
		</style>
		<style>
			/* Debug panel styles */
			#debugToggle {
				display: none;
				position: absolute;
				top: 20px;
				right: 20px;
				padding: 8px 12px;
				font-size: 12px;
				background-color: rgba(255, 165, 0, 0.9);
				color: #000;
				border: none;
				border-radius: 6px;
				cursor: pointer;
				z-index: 100;
				font-weight: 600;
			}

			#debugToggle.show {
				display: block;
			}

			#debugPanel {
				display: none;
				position: absolute;
				top: 60px;
				right: 10px;
				left: 10px;
				max-height: 50vh;
				background-color: rgba(0, 0, 0, 0.9);
				border: 2px solid orange;
				border-radius: 8px;
				z-index: 99;
				overflow: hidden;
				flex-direction: column;
			}

			#debugPanel.show {
				display: flex;
			}

			#debugHeader {
				display: flex;
				justify-content: space-between;
				align-items: center;
				padding: 8px 12px;
				background-color: rgba(255, 165, 0, 0.2);
				border-bottom: 1px solid orange;
			}

			#debugHeader span {
				color: orange;
				font-weight: 600;
				font-size: 12px;
			}

			#debugClear {
				padding: 4px 8px;
				font-size: 11px;
				background-color: rgba(255, 100, 100, 0.8);
				color: #fff;
				border: none;
				border-radius: 4px;
				cursor: pointer;
			}

			#debugLogs {
				flex: 1;
				overflow-y: auto;
				padding: 8px;
				font-family: monospace;
				font-size: 11px;
				line-height: 1.4;
				color: #0f0;
			}

			.debug-entry {
				margin-bottom: 4px;
				padding-bottom: 4px;
				border-bottom: 1px solid rgba(255, 255, 255, 0.1);
				word-break: break-word;
			}

			.debug-entry .timestamp {
				color: #888;
			}

			.debug-entry .message {
				color: #0f0;
			}

			.debug-entry .data {
				color: #0ff;
				margin-left: 10px;
				display: block;
			}

			.debug-entry.error .message {
				color: #f66;
			}
		</style>
	</head>
	<body>
		<div id="container">
			<video id="mainVideo" autoplay playsinline></video>
			<video id="overlayVideo" autoplay playsinline></video>
			<div id="overlayError">
				<div class="error-content">
					<div class="error-icon">⚠️</div>
					<div class="error-message">Second camera not available</div>
				</div>
			</div>

			<div id="controls">
				<button id="switchBtn">Switch Cameras</button>
				<button id="captureBtn">Capture Photo</button>
			</div>

			<div id="status"></div>

			<!-- Debug UI (only visible in debug mode) -->
			<button id="debugToggle">Show Logs</button>
			<div id="debugPanel">
				<div id="debugHeader">
					<span>Debug Logs</span>
					<button id="debugClear">Clear</button>
				</div>
				<div id="debugLogs"></div>
			</div>
		</div>

		<canvas id="canvas"></canvas>

		<script type="module" id="debug">
			// Check for debug mode via URL parameter
			const urlParams = new URLSearchParams(window.location.search);
			const DEBUG = urlParams.has("debug");
			let debugPanelVisible = false;

			function debugLog(message, data = null, isError = false) {
				if (!DEBUG) return;
				const timestamp = new Date().toISOString().split("T")[1].slice(0, 12);

				// Console logging
				if (data !== null) {
					console.log(`[DEBUG ${timestamp}] ${message}`, data);
				} else {
					console.log(`[DEBUG ${timestamp}] ${message}`);
				}

				// On-screen logging
				const logsContainer = document.getElementById("debugLogs");
				if (logsContainer) {
					const entry = document.createElement("div");
					entry.className = "debug-entry" + (isError ? " error" : "");

					const escapedMsg = escapeHtml(message);
					let html = `<span class="timestamp">[${timestamp}]</span> <span class="message">${escapedMsg}</span>`;
					if (data !== null) {
						let dataStr;
						try {
							dataStr = JSON.stringify(data, null, 2);
						} catch (e) {
							dataStr = String(data);
						}
						html += `<span class="data">${escapeHtml(dataStr)}</span>`;
					}

					entry.innerHTML = html;
					logsContainer.appendChild(entry);
					logsContainer.scrollTop = logsContainer.scrollHeight;
				}
			}

			function escapeHtml(text) {
				const div = document.createElement("div");
				div.textContent = text;
				return div.innerHTML;
			}

			function toggleDebugPanel() {
				debugPanelVisible = !debugPanelVisible;
				const panel = document.getElementById("debugPanel");
				const toggle = document.getElementById("debugToggle");
				if (debugPanelVisible) {
					panel.classList.add("show");
					toggle.textContent = "Hide Logs";
				} else {
					panel.classList.remove("show");
					toggle.textContent = "Show Logs";
				}
			}

			function clearDebugLogs() {
				const logsContainer = document.getElementById("debugLogs");
				if (logsContainer) {
					logsContainer.innerHTML = "";
				}
				debugLog("Logs cleared");
			}

			// Debug button event listeners
			document.getElementById("debugToggle").addEventListener("click", toggleDebugPanel);
			document.getElementById("debugClear").addEventListener("click", clearDebugLogs);

			if (DEBUG) {
				// Show debug toggle button
				document.getElementById("debugToggle").classList.add("show");

				console.log("=== DEBUG MODE ENABLED ===");
				console.log("User Agent:", navigator.userAgent);
				console.log("URL:", window.location.href);

				debugLog("DEBUG MODE ENABLED");
				debugLog("User Agent: " + navigator.userAgent);
				debugLog("URL: " + window.location.href);
			}

			globalThis.DEBUG = DEBUG;
			globalThis.debugLog = debugLog;
		</script>
		<script type="module" id="main">
			let mainStream = null;
			let overlayStream = null;
			let mainVideoElement = document.getElementById("mainVideo");
			let overlayVideoElement = document.getElementById("overlayVideo");
			let isMainFront = false; // false = back camera is main, true = front camera is main

			async function initCameras() {
				debugLog("initCameras() called");

				/** @type {MediaStream | null} */
				let backStream = null;
				/** @type {MediaStream | null} */
				let frontStream = null;

				try {
					showStatus("Initializing cameras...");

					// Log available devices first
					if (DEBUG) {
						try {
							const devices = await navigator.mediaDevices.enumerateDevices();
							const videoDevices = devices.filter(
								(d) => d.kind === "videoinput"
							);
							debugLog(`Found ${videoDevices.length} video input device(s):`);
							videoDevices.forEach((d, i) => {
								debugLog(
									`  Device ${i}: ${
										d.label || "(no label)"
									} [${d.deviceId.slice(0, 8)}...]`
								);
							});
						} catch (e) {
							debugLog("Failed to enumerate devices", e, true);
						}
					}

					// Try to get back camera
					debugLog(
						"Attempting to get back camera (facingMode: environment)..."
					);
					try {
						backStream = await navigator.mediaDevices.getUserMedia({
							video: { facingMode: { exact: "environment" } },
							audio: false,
						});
						debugLog("Back camera obtained successfully", {
							tracks: backStream.getVideoTracks().map((t) => ({
								label: t.label,
								enabled: t.enabled,
								readyState: t.readyState,
								settings: t.getSettings(),
							})),
						});
					} catch (e) {
						debugLog(
							"Back camera not available",
							{ name: e.name, message: e.message },
							true
						);
						console.log("Back camera not available:", e);
					}

					// Try to get front camera
					debugLog("Attempting to get front camera (facingMode: user)...");
					try {
						frontStream = await navigator.mediaDevices.getUserMedia({
							video: { facingMode: "user" },
							audio: false,
						});
						debugLog("Front camera obtained successfully", {
							tracks: frontStream.getVideoTracks().map((t) => ({
								label: t.label,
								enabled: t.enabled,
								readyState: t.readyState,
								settings: t.getSettings(),
							})),
						});
					} catch (e) {
						debugLog(
							"Front camera not available",
							{ name: e.name, message: e.message },
							true
						);
						console.log("Front camera not available:", e);
					}

					// Check what we got
					debugLog("Stream results", {
						hasBack: !!backStream,
						hasFront: !!frontStream,
					});

					if (backStream && frontStream) {
						// Both cameras available
						debugLog("Both cameras available - dual camera mode");
						mainStream = backStream;
						overlayStream = frontStream;
						mainVideoElement.srcObject = mainStream;
						overlayVideoElement.srcObject = overlayStream;
						updateCameraOrientation();
						showStatus("Cameras ready!", 2000);
					} else if (backStream || frontStream) {
						// Only one camera available
						debugLog("Only one camera available - single camera mode", {
							usingBack: !!backStream,
							usingFront: !!frontStream,
						});
						mainStream = backStream || frontStream;
						isMainFront = !!frontStream; // true if front camera is the only one
						mainVideoElement.srcObject = mainStream;
						updateCameraOrientation();
						document.getElementById("overlayError").classList.add("show");
						document.getElementById("switchBtn").disabled = true;
						document.getElementById("switchBtn").style.opacity = "0.5";
						document.getElementById("switchBtn").style.cursor = "not-allowed";
						showStatus("Single camera mode", 2000);
					} else {
						// No cameras via facingMode, try device enumeration
						debugLog("FacingMode failed, falling back to device enumeration");
						const devices = await navigator.mediaDevices.enumerateDevices();
						const videoDevices = devices.filter(
							(device) => device.kind === "videoinput"
						);
						debugLog(
							`Device enumeration found ${videoDevices.length} video device(s)`
						);

						if (videoDevices.length >= 2) {
							debugLog("Attempting to open two cameras by deviceId");
							const stream1 = await navigator.mediaDevices.getUserMedia({
								video: { deviceId: videoDevices[0].deviceId },
							});
							debugLog("First camera opened", {
								deviceId: videoDevices[0].deviceId.slice(0, 8),
							});
							const stream2 = await navigator.mediaDevices.getUserMedia({
								video: { deviceId: videoDevices[1].deviceId },
							});
							debugLog("Second camera opened", {
								deviceId: videoDevices[1].deviceId.slice(0, 8),
							});

							mainStream = stream1;
							overlayStream = stream2;
							mainVideoElement.srcObject = mainStream;
							overlayVideoElement.srcObject = overlayStream;
							showStatus("Cameras ready!", 2000);
						} else if (videoDevices.length === 1) {
							debugLog(
								"Only one device found via enumeration - single camera mode"
							);
							const stream = await navigator.mediaDevices.getUserMedia({
								video: { deviceId: videoDevices[0].deviceId },
							});

							mainStream = stream;
							mainVideoElement.srcObject = mainStream;
							document.getElementById("overlayError").classList.add("show");
							document.getElementById("switchBtn").disabled = true;
							document.getElementById("switchBtn").style.opacity = "0.5";
							document.getElementById("switchBtn").style.cursor = "not-allowed";
							showStatus("Single camera mode", 2000);
						} else {
							debugLog("No video devices found at all", null, true);
							showStatus("Error: No cameras found");
						}
					}
				} catch (error) {
					debugLog(
						"FATAL ERROR in initCameras",
						{
							name: error.name,
							message: error.message,
							stack: error.stack,
						},
						true
					);
					console.error("Error accessing cameras:", error);
					showStatus("Error: " + error.message);
				}
			}

			function updateCameraOrientation() {
				debugLog("updateCameraOrientation()", { isMainFront: isMainFront });
				// Update CSS classes based on which camera is showing where
				if (isMainFront) {
					mainVideoElement.classList.add("front-camera");
				} else {
					mainVideoElement.classList.remove("front-camera");
				}

				// Overlay video shows the opposite camera of main
				if (overlayStream) {
					if (isMainFront) {
						overlayVideoElement.classList.remove("front-camera");
					} else {
						overlayVideoElement.classList.add("front-camera");
					}
				}
			}

			function switchCameras() {
				debugLog("switchCameras() called", {
					mainStreamActive: mainStream?.active,
					overlayStreamActive: overlayStream?.active,
					isMainFront: isMainFront,
				});

				// Swap the streams
				const tempStream = mainStream;
				mainStream = overlayStream;
				overlayStream = tempStream;

				mainVideoElement.srcObject = mainStream;
				overlayVideoElement.srcObject = overlayStream;

				isMainFront = !isMainFront;
				updateCameraOrientation();
				debugLog("Cameras switched", { isMainFront: isMainFront });
				showStatus("Cameras switched!", 1500);
			}

			function capturePhoto() {
				debugLog("capturePhoto() called", {
					mainVideoWidth: mainVideoElement.videoWidth,
					mainVideoHeight: mainVideoElement.videoHeight,
					mainStreamActive: mainStream?.active,
					overlayStreamActive: overlayStream?.active,
					hasOverlay: !!overlayStream,
				});

				const canvas = document.getElementById("canvas");
				const ctx = canvas.getContext("2d");

				// Set canvas size to match main video
				canvas.width = mainVideoElement.videoWidth;
				canvas.height = mainVideoElement.videoHeight;

				if (canvas.width === 0 || canvas.height === 0) {
					debugLog(
						"WARNING: Canvas size is 0, video may not be ready",
						null,
						true
					);
				}

				// Draw main video feed with flip if front camera
				ctx.save();
				if (isMainFront) {
					ctx.translate(canvas.width, 0);
					ctx.scale(-1, 1);
				}
				ctx.drawImage(mainVideoElement, 0, 0, canvas.width, canvas.height);
				ctx.restore();

				// Calculate overlay position and size (top-left corner, maintaining aspect ratio)
				const overlayWidth = canvas.width * 0.25; // 25% of main width
				const overlayX = 20;
				const overlayY = 20;
				const borderRadius = 12;

				if (overlayStream) {
					// Draw second camera overlay
					const overlayHeight =
						(overlayVideoElement.videoHeight / overlayVideoElement.videoWidth) *
						overlayWidth;

					// Draw rounded rectangle for overlay background/border
					ctx.save();
					ctx.beginPath();
					ctx.moveTo(overlayX + borderRadius, overlayY);
					ctx.lineTo(overlayX + overlayWidth - borderRadius, overlayY);
					ctx.quadraticCurveTo(
						overlayX + overlayWidth,
						overlayY,
						overlayX + overlayWidth,
						overlayY + borderRadius
					);
					ctx.lineTo(
						overlayX + overlayWidth,
						overlayY + overlayHeight - borderRadius
					);
					ctx.quadraticCurveTo(
						overlayX + overlayWidth,
						overlayY + overlayHeight,
						overlayX + overlayWidth - borderRadius,
						overlayY + overlayHeight
					);
					ctx.lineTo(overlayX + borderRadius, overlayY + overlayHeight);
					ctx.quadraticCurveTo(
						overlayX,
						overlayY + overlayHeight,
						overlayX,
						overlayY + overlayHeight - borderRadius
					);
					ctx.lineTo(overlayX, overlayY + borderRadius);
					ctx.quadraticCurveTo(
						overlayX,
						overlayY,
						overlayX + borderRadius,
						overlayY
					);
					ctx.closePath();

					// Draw black border
					ctx.strokeStyle = "#000";
					ctx.lineWidth = 6;
					ctx.stroke();

					// Clip to rounded rectangle and draw overlay video
					ctx.clip();

					// Apply flip if overlay is showing front camera
					if (!isMainFront) {
						ctx.translate(overlayX + overlayWidth, overlayY);
						ctx.scale(-1, 1);
						ctx.translate(-overlayX, -overlayY);
					}

					ctx.drawImage(
						overlayVideoElement,
						overlayX,
						overlayY,
						overlayWidth,
						overlayHeight
					);
					ctx.restore();
				} else {
					// Draw error overlay instead
					const overlayHeight = overlayWidth * (4 / 3); // 4:3 aspect ratio for error box

					// Draw rounded rectangle with error styling
					ctx.save();

					// Background
					ctx.beginPath();
					ctx.moveTo(overlayX + borderRadius, overlayY);
					ctx.lineTo(overlayX + overlayWidth - borderRadius, overlayY);
					ctx.quadraticCurveTo(
						overlayX + overlayWidth,
						overlayY,
						overlayX + overlayWidth,
						overlayY + borderRadius
					);
					ctx.lineTo(
						overlayX + overlayWidth,
						overlayY + overlayHeight - borderRadius
					);
					ctx.quadraticCurveTo(
						overlayX + overlayWidth,
						overlayY + overlayHeight,
						overlayX + overlayWidth - borderRadius,
						overlayY + overlayHeight
					);
					ctx.lineTo(overlayX + borderRadius, overlayY + overlayHeight);
					ctx.quadraticCurveTo(
						overlayX,
						overlayY + overlayHeight,
						overlayX,
						overlayY + overlayHeight - borderRadius
					);
					ctx.lineTo(overlayX, overlayY + borderRadius);
					ctx.quadraticCurveTo(
						overlayX,
						overlayY,
						overlayX + borderRadius,
						overlayY
					);
					ctx.closePath();

					ctx.fillStyle = "rgba(40, 40, 40, 0.95)";
					ctx.fill();

					// Red border
					ctx.strokeStyle = "#ff6b6b";
					ctx.lineWidth = 6;
					ctx.stroke();

					// Draw error text
					ctx.fillStyle = "#fff";
					ctx.textAlign = "center";
					ctx.textBaseline = "middle";
					ctx.font = "bold 40px Arial";
					ctx.fillText(
						"⚠️",
						overlayX + overlayWidth / 2,
						overlayY + overlayHeight / 2 - 20
					);
					ctx.font = "14px Arial";
					ctx.fillText(
						"Second camera",
						overlayX + overlayWidth / 2,
						overlayY + overlayHeight / 2 + 20
					);
					ctx.fillText(
						"not available",
						overlayX + overlayWidth / 2,
						overlayY + overlayHeight / 2 + 38
					);

					ctx.restore();
				}

				// Convert to blob and download
				debugLog("Converting canvas to blob...");
				canvas.toBlob((blob) => {
					if (!blob) {
						debugLog("ERROR: Failed to create blob from canvas", null, true);
						showStatus("Error: Failed to capture photo");
						return;
					}

					debugLog("Blob created", { size: blob.size, type: blob.type });
					const url = URL.createObjectURL(blob);
					const a = document.createElement("a");
					a.href = url;
					a.download = `dual-camera-${Date.now()}.png`;
					debugLog("Initiating download", { filename: a.download });
					document.body.appendChild(a);
					a.click();
					document.body.removeChild(a);
					URL.revokeObjectURL(url);

					debugLog("Photo capture complete");
					showStatus("Photo captured!", 2000);
				}, "image/png");
			}

			function showStatus(message, duration = null) {
				const statusElement = document.getElementById("status");
				statusElement.textContent = message;
				statusElement.classList.add("show");

				if (duration) {
					setTimeout(() => {
						statusElement.classList.remove("show");
					}, duration);
				}
			}

			// Click on overlay to switch cameras
			document.getElementById("overlayVideo").addEventListener("click", () => {
				debugLog("Overlay video clicked");
				switchCameras();
			});

			// Button click handlers
			document.getElementById("switchBtn").addEventListener("click", () => {
				debugLog("Switch button clicked");
				switchCameras();
			});
			document.getElementById("captureBtn").addEventListener("click", () => {
				debugLog("Capture button clicked");
				capturePhoto();
			});

			// Initialize cameras when page loads
			debugLog("Page loaded, starting camera initialization");
			initCameras();
		</script>
	</body>
</html>
